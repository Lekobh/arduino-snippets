{
  "abs": {
    "body": "abs(${1:x});$0",
    "description": "Calculates the absolute value of a number.",
    "prefix": "abs"
  },
  "analogRead": {
    "body": "analogRead(${1:pin});$0",
    "description": "Reads the value from the specified analog pin.",
    "prefix": "analogRead"
  },
  "analogWrite": {
    "body": "analogWrite(${1:pin}, ${2:value});$0",
    "description": "Writes an analog value to a pin.",
    "prefix": "analogWrite"
  },
  "arduino": {
    "body": "void setup()\n{\n\t$0\n}\n\nvoid loop()\n{\n\t\n}",
    "description": "Builds the body of an arduino program.",
    "prefix": "arduino"
  },
  "attachInterrupt": {
    "body": "attachInterrupt(${1:interrupt}, ${2:function}, ${3:mode});$0",
    "description": "Digital Pins With Interrupts.",
    "prefix": "attachInterrupt"
  },
  "byte": {
    "body": "byte(${1:x});$0",
    "description": "Converts a value to the byte data type.",
    "prefix": "byte"
  },
  "char": {
    "body": "char(${1:x});$0",
    "description": "Converts a value to the char data type.",
    "prefix": "char"
  },
  "constrain": {
    "body": "constrain(${1:x}, ${2:a}, ${3:b});$0",
    "description": "Constrains a number to be within a range.",
    "prefix": "constrain"
  },
  "define": {
    "body": "define ${1:IDENTIFIER} ${2:string}$0",
    "description": "Directive that causes the compiler to substitute token-string for each occurrence of identifier in the source file",
    "prefix": "define"
  },
  "delay": {
    "body": "delay(${1:ms});$0",
    "description": "Pauses the program for the amount of time (in milliseconds) specified as parameter. (There are 1000 milliseconds in a second.)",
    "prefix": "delay"
  },
  "delayMicroseconds": {
    "body": "delayMicroseconds(${1:us});$0",
    "description": "Pauses the program for the amount of time (in microseconds) specified as parameter.",
    "prefix": "delayMicroseconds"
  },
  "detachInterrupt": {
    "body": "detachInterrupt(${1:interrupt});$0",
    "description": "Turns off the given interrupt.",
    "prefix": "detachInterrupt"
  },
  "digitalRead": {
    "body": "digitalRead(${1:pin});$0",
    "description": "Reads the value from a specified digital pin, either HIGH or LOW.",
    "prefix": "digitalRead"
  },
  "digitalWrite": {
    "body": "digitalWrite(${1:pin}, ${2:value});$0",
    "description": "Write a HIGH or a LOW value to a digital pin.",
    "prefix": "digitalWrite"
  },
  "dowhile": {
    "body": "do{\n    ${1:// statement block}\n} while (${2:test condition});$0",
    "description": "The do…​while loop works in the same manner as the while loop, with the exception that the condition is tested at the end of the loop, so the do loop will always run at least once",
    "prefix": "dowhile"
  },
  "float": {
    "body": "float(${1:x});$0",
    "description": "Converts a value to the float data type.",
    "prefix": "float"
  },
  "for": {
    "body": "for(int ${1:i}=0; ${1:i}<${2}; ${1}++){\n    ${3}\n}$0",
    "description": "The for statement is used to repeat a block of statements enclosed in curly braces.",
    "prefix": "for"
  },
  "if": {
    "body": "if(${1}){\n    ${2}\n}$0",
    "description": "The if statement checks for a condition and executes the proceeding statement or set of statements if the condition is 'true'.",
    "prefix": "if"
  },
  "ifdef": {
    "body": "ifdef ${1:constant-expression}$0",
    "description": "The #ifdef directive checks for the existence of macro definitions.",
    "prefix": "ifdef"
  },
  "scope": "source.arduino(C++)",
  "ifndef": {
    "body": "ifndef ${1:constant-expression}$0",
    "description": "The #ifdef directive checks for the inexistence of macro definitions.",
    "prefix": "ifndef"
  },
  "include": {
    "body": "include \"${1:lib.h}\"$0",
    "description": "Arduino(C++) include userlib",
    "prefix": "include"
  },
  "include": {
    "body": "include <${1:lib.h}>$0",
    "description": "#include is used to include outside libraries in your sketch.",
    "prefix": "include"
  },
  "int": {
    "body": "int(${1:x});$0",
    "description": "Converts a value to the int data type.",
    "prefix": "int"
  },
  "long": {
    "body": "long(${1:x});$0",
    "description": "Converts a value to the long data type.",
    "prefix": "long"
  },
  "loop": {
    "body": "void loop()\n{\n\t$1\n}$0",
    "description": "The loop() function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond.",
    "prefix": "loop"
  },
  "map": {
    "body": "map(${1:value}, ${2:fromLow}, ${3:fromHigh}, ${4:toLow}, ${5:toHigh});$0",
    "description": "Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.",
    "prefix": "map"
  },
  "max": {
    "body": "max(${1:x}, ${2:y});$0",
    "description": "Calculates the maximum of two numbers.",
    "prefix": "max"
  },
  "elif": {
    "body": "elif ${1:constant-expression}$0",
    "description": "Macro elif",
    "prefix": "elif"
  },
  "micros": {
    "body": "micros();$0",
    "description": "Returns the number of microseconds since the Arduino board began running the current program.",
    "prefix": "micros"
  },
  "if": {
    "body": "if ${1:constant-expression}$0",
    "description": "The if statement checks for a condition and executes the proceeding statement or set of statements if the condition is 'true'.",
    "prefix": "if"
  },
  "millis": {
    "body": "millis();$0",
    "description": "Returns the number of milliseconds since the Arduino board began running the current program.",
    "prefix": "millis"
  },
  "min": {
    "body": "min(${1:x}, ${2:y});$0",
    "description": "Calculates the minimum of two numbers.",
    "prefix": "min"
  },
  "noTone": {
    "body": "noTone(${1:pin});$0",
    "description": "Stops the generation of a square wave triggered by tone(). Has no effect if no tone is being generated.",
    "prefix": "noTone"
  },
  "pinMode": {
    "body": "pinMode(${1:pin}, ${2:mode});$0",
    "description": "Configures the specified pin to behave either as an input or an output.",
    "prefix": "pinMode"
  },
  "pow": {
    "body": "pow(${1:base}, ${2:exponent});$0",
    "description": "Calculates the value of a number raised to a power. Pow() can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.",
    "prefix": "pow"
  },
  "pulseIn": {
    "body": "pulseIn(${1:pin}, ${2:value}, ${3:timeout});$0",
    "description": "Reads a pulse on a pin. Waits for the pin state change, starts timing, then waits for the pin to go change again and stops timing. Returns the length of the pulse in microseconds or gives up and returns 0 if no complete pulse was received within the timeout.",
    "prefix": "pulseIn"
  },
  "random": {
    "body": "random(${1:min}, ${2:max});$0",
    "description": "The random function generates pseudo-random numbers.",
    "prefix": "random"
  },
  "randomSeed": {
    "body": "randomSeed(${1:seed});$0",
    "description": "Initializes the pseudo-random number generator. To initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.",
    "prefix": "randomSeed"
  },
  "savailable": {
    "body": "if (Serial.available() > ${1:0}) {\n    ${2}\n}$0",
    "description": "Get the number of bytes (characters) available for reading from the serial port.",
    "prefix": "savailable"
  },
  "sbegin": {
    "body": "Serial.begin(${1:9600});$0",
    "description": "Sets the data rate in bits per second (baud) for serial data transmission. An optional second argument configures the data, parity, and stop bits. The default is 8 data bits, no parity, one stop bit.",
    "prefix": "sbegin"
  },
  "send": {
    "body": "Serial.end();$0",
    "description": "Disables serial communication, allowing the RX and TX pins to be used for general input and output. To re-enable serial communication, call Serial.begin().",
    "prefix": "send"
  },
  "sevent": {
    "body": "void serialEvent(){\n    ${1://statements}\n}$0",
    "description": "Called when data is available. Use Serial.read() to capture this data.",
    "prefix": "sevent"
  },
  "sfind": {
    "body": "Serial.find(${1:target});$0",
    "description": "Serial.find() reads data from the serial buffer until the target string of given length is found. The function returns true if target string is found, false if it times out.",
    "prefix": "sfind"
  },
  "sfindUntil": {
    "body": "Serial.findUntil(${1:target}, ${2:terminal});$0",
    "description": "Serial.findUntil() reads data from the serial buffer until a target string of given length or terminator string is found.",
    "prefix": "sfindUntil"
  },
  "sflush": {
    "body": "Serial.flush();$0",
    "description": "Waits for the transmission of outgoing serial data to complete.",
    "prefix": "sflush"
  },
  "spfloat": {
    "body": "Serial.parseFloat();$0",
    "description": "Serial.parseFloat() returns the first valid floating point number from the Serial buffer. Characters that are not digits (or the minus sign) are skipped.",
    "prefix": "spfloat"
  },
  "spint": {
    "body": "Serial.parseInt();$0",
    "description": "Looks for the next valid integer in the incoming serial stream.",
    "prefix": "spint"
  },
  "speek": {
    "body": "Serial.peek();$0",
    "description": "Returns the next byte (character) of incoming serial data without removing it from the internal serial buffer.",
    "prefix": "speek"
  },
  "sprint": {
    "body": "Serial.print(${1:val}, ${2:format});$0",
    "description": "Prints data to the serial port as human-readable ASCII text.",
    "prefix": "sprint"
  },
  "sprintln": {
    "body": "Serial.println(${1:val}, ${2:format});$0",
    "description": "Prints data to the serial port as human-readable ASCII text followed by a carriage return character and a newline character",
    "prefix": "sprint"
  },
  "sread": {
    "body": "Serial.read();$0",
    "description": "Reads incoming serial data.",
    "prefix": "sread"
  },
  "sreadBytes": {
    "body": "Serial.readBytes(${1:buffer}, ${2:length});$0",
    "description": "Serial.readBytes() reads characters from the serial port into a buffer. The function terminates if the determined length has been read, or it times out.",
    "prefix": "sreadBytes"
  },
  "sreadBytesUntil": {
    "body": "Serial.readBytesUntil(${1:character}, ${2:buffer}, ${2:length});$0",
    "description": "Serial.readBytesUntil() reads characters from the serial buffer into an array. The function terminates if the terminator character is detected, the determined length has been read, or it times out.",
    "prefix": "sreadBytesUntil"
  },
  "stimeout": {
    "body": "Serial.setTimeout(${1:time});$0",
    "description": "Serial.setTimeout() sets the maximum milliseconds to wait for serial data when using serial.readBytesUntil() or serial.readBytes(). It defaults to 1000 milliseconds.",
    "prefix": "stimeout"
  },
  "swrite": {
    "body": "Serial.write(${1:data});$0",
    "description": "Writes binary data to the serial port. This data is sent as a byte or series of bytes.",
    "prefix": "swrite"
  },
  "setup": {
    "body": "void setup()\n{\n\t$1\n}$0",
    "description": "The setup() function is called when a sketch starts.",
    "prefix": "setup"
  },
  "shiftIn": {
    "body": "shiftIn(${1:dataPin}, ${2:clockPin}, ${3:bitOrder});$0",
    "description": "Shifts in a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit.",
    "prefix": "shiftIn"
  },
  "shiftOut": {
    "body": "shiftOut(${1:dataPin}, ${2:clockPin}, ${3:bitOrder}, ${4:value});$0",
    "description": "Shifts out a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit.",
    "prefix": "shiftOut"
  },
  "sizeof": {
    "body": "sizeof(${1:variable});$0",
    "description": "The sizeof operator returns the number of bytes in a variable type, or the number of bytes occupied by an array.",
    "prefix": "sizeof"
  },
  "sqrt": {
    "body": "sqrt(${1:x});$0",
    "description": "Calculates the square root of a number.",
    "prefix": "sqrt"
  },
  "switch": {
    "body": "switch (${1}) {\n    case ${2}:\n      ${3:// do something}\n      break;\n    case ${4}:\n      ${5:// do something}\n      break;\n    default:\n      ${6:// do something}\n}$0",
    "description": "Switch statement",
    "prefix": "switch"
  },
  "tone": {
    "body": "tone(${1:pin}, ${2:frequency}, ${3:duration});$0",
    "description": "Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. A duration can be specified, otherwise the wave continues until a call to noTone().",
    "prefix": "tone"
  },
  "undef": {
    "body": "undef ${1:constant-expression}$0",
    "description": "Macro undef",
    "prefix": "undef"
  },
  "while": {
    "body": "while(${1}){\n    ${2:// statement}\n}$0",
    "description": "While statement",
    "prefix": "while"
  }
}
